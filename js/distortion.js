// Generated by CoffeeScript 1.12.6
var Distortion, types,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

types = ['clip', 'foldback', 'random', 'overflow', 'zero'];

Distortion = (function() {
  function Distortion(opts) {
    var ref, ref1;
    if (opts == null) {
      throw new Error('Required arguments');
    }
    if (((ref = opts.signal) != null ? ref.tf : void 0) == null) {
      throw new Error('Required signal (Object with .tf())');
    }
    this.signal = opts.signal;
    if (opts.level == null) {
      opts.level = 0.5;
    }
    if (typeof opts.level !== 'number') {
      throw new Error('Level must be numeric');
    }
    this.level = opts.level;
    if (opts.type == null) {
      opts.type = 'clip';
    }
    if (typeof opts.type !== 'string') {
      throw new Error('Type must be a string');
    }
    if (ref1 = opts.type, indexOf.call(types, ref1) < 0) {
      throw new Error("Type unknown or not supported: " + opts.type);
    }
    this.type = opts.type;
  }

  Distortion.prototype.clone = function() {
    var d, l, s, t;
    s = this.signal.clone != null ? this.signal.clone() : this.signal;
    l = this.level.clone != null ? this.level.clone() : this.level;
    t = this.type.clone != null ? this.type.clone() : this.type;
    d = new Distortion({
      signal: s,
      level: l,
      type: t
    });
    return d;
  };

  Distortion.prototype.tf = function(t) {
    var o, osc, ref, ref1, ref2, ref3, ref4, type;
    osc = this.signal;
    type = this.type;
    o = function(t) {
      return osc.tf(t);
    };
    switch (type) {
      case 'clip':
        if ((-this.level <= (ref = o(t)) && ref <= this.level)) {
          return o(t);
        } else if (o(t) > this.level) {
          return this.level;
        } else {
          return -this.level;
        }
        break;
      case 'foldback':
        if ((-this.level <= (ref1 = o(t)) && ref1 <= this.level)) {
          return o(t);
        } else if (o(t) > this.level) {
          return 2 * this.level - o(t);
        } else {
          return -2 * this.level - o(t);
        }
        break;
      case 'random':
        if ((-this.level <= (ref2 = o(t)) && ref2 <= this.level)) {
          return o(t);
        } else if (o(t) > this.level) {
          return (Math.random() * 2 - 1) * this.level;
        } else {
          return (Math.random() * 2 - 1) * this.level;
        }
        break;
      case 'overflow':
        if ((-this.level <= (ref3 = o(t)) && ref3 <= this.level)) {
          return o(t);
        } else if (o(t) > this.level) {
          return -2 * this.level + o(t);
        } else {
          return 2 * this.level + o(t);
        }
        break;
      case 'zero':
        if ((-this.level <= (ref4 = o(t)) && ref4 <= this.level)) {
          return o(t);
        } else {
          return 0;
        }
        break;
      default:
        return o(t);
    }
  };

  return Distortion;

})();

module.exports = Distortion;
