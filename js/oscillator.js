// Generated by CoffeeScript 1.12.6
var Osc, types, wave_sawtooth, wave_sine, wave_square, wave_triangle,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

types = ['sine', 'square', 'triangle', 'sawtooth'];

Osc = (function() {
  function Osc(opts) {
    var ref;
    if (!(opts && opts.freq)) {
      throw new Error('Missing Frequency Value');
    }
    if (typeof opts.freq !== 'number') {
      throw new Error("Frequency must be numeric");
    }
    this.freq = opts.freq;
    if (opts.amp == null) {
      opts.amp = 1;
    }
    if (!((opts.amp.tf != null) || typeof opts.amp === 'number')) {
      throw new Error('Amplitude must be numeric, Osc or Env');
    }
    this.amp = opts.amp;
    if (opts.phase == null) {
      opts.phase = 0;
    }
    if (!((opts.phase.tf != null) || typeof opts.phase === 'number')) {
      throw new Error('Phase must be numeric, Osc or Env');
    }
    this.phase = opts.phase;
    if (opts.type == null) {
      opts.type = 'sine';
    }
    if (ref = opts.type, indexOf.call(types, ref) < 0) {
      throw new Error('Type must be string supported');
    }
    this.type = opts.type;
  }

  Osc.prototype.getAmp = function() {
    return this.amp;
  };

  Osc.prototype.getFreq = function() {
    return this.freq;
  };

  Osc.prototype.getPhase = function() {
    return this.phase;
  };

  Osc.prototype.getType = function() {
    return this.type;
  };

  Osc.prototype.tf = function(t) {
    var a, f_amp, f_phase, ph;
    a = this.amp;
    f_amp = function(t) {
      var ref;
      return (ref = typeof a.tf === "function" ? a.tf(t) : void 0) != null ? ref : a;
    };
    ph = this.phase;
    f_phase = function(t) {
      var ref;
      return (ref = typeof ph.tf === "function" ? ph.tf(t) : void 0) != null ? ref : ph;
    };
    switch (this.type) {
      case 'sine':
        return wave_sine(t, f_amp, this.freq, f_phase);
      case 'square':
        return wave_square(t, f_amp, this.freq, f_phase);
      case 'triangle':
        return wave_triangle(t, f_amp, this.freq, f_phase);
      case 'sawtooth':
        return wave_sawtooth(t, f_amp, this.freq, f_phase);
      default:
        throw new Error('Waveform Type Selection Error');
    }
  };

  return Osc;

})();

wave_sine = function(t, f_amp, freq, f_phase) {
  return Math.sin(2 * Math.PI * t * freq + f_phase(t)) * f_amp(t);
};

wave_square = function(t, f_amp, freq, f_phase) {
  if (Math.sin(2 * Math.PI * t * freq + f_phase(t)) > 0) {
    return f_amp(t);
  } else {
    return -f_amp(t);
  }
};

wave_triangle = function(t, f_amp, freq, f_phase) {
  var time;
  time = Math.asin(Math.sin(2 * Math.PI * freq * t + f_phase(t)));
  time /= Math.PI / 2;
  return time * f_amp(t);
};

wave_sawtooth = function(t, f_amp, freq, f_phase) {
  return -(2 * f_amp(t) / Math.PI) * Math.atan(1 / Math.tan(t * Math.PI * freq + Math.PI / 2 + f_phase(t) / 2));
};

module.exports = Osc;
